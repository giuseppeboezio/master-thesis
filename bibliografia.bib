@article{10.1145/155360.155362,
author = {Colmerauer, Alain and Roussel, Philippe},
title = {The Birth of Prolog},
year = {1993},
issue_date = {March 1993},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {28},
number = {3},
issn = {0362-1340},
url = {https://doi.org/10.1145/155360.155362},
doi = {10.1145/155360.155362},
abstract = {The programming language, Prolog, was born of a project aimed not at producing a programming language but at processing natural languages; in this case, French. The project gave rise to a preliminary version of Prolog at the end of 1971 and a more definitive version at the end of 1972. This article gives the history of this project and describes in detail the preliminary and then the final versions of Prolog. The authors also felt it appropriate to describe the Q-systems since it was a language which played a prominent part in Prolog's genesis.},
journal = {SIGPLAN Not.},
month = {mar},
pages = {37–52},
numpages = {16}
}

@article{coelho1986automated,
  title={Automated reasoning in geometry theorem proving with Prolog},
  author={Coelho, Helder and Pereira, Luis Moniz},
  journal={Journal of Automated Reasoning},
  volume={2},
  number={4},
  pages={329--390},
  year={1986},
  publisher={Springer}
}

@book{merritt2012building,
  title={Building expert systems in Prolog},
  author={Merritt, Dennis},
  year={2012},
  publisher={Springer Science \& Business Media}
}

@article{gelfond2002logic,
  title={Logic programming and knowledge representation—the A-Prolog perspective},
  author={Gelfond, Michael and Leone, Nicola},
  journal={Artificial Intelligence},
  volume={138},
  number={1-2},
  pages={3--38},
  year={2002},
  publisher={Elsevier}
}

@article{pinna2015resolving,
  title={Resolving model inconsistencies using automated regression planning},
  author={Pinna Puissant, Jorge and Van Der Straeten, Ragnhild and Mens, Tom},
  journal={Software \& Systems Modeling},
  volume={14},
  number={1},
  pages={461--481},
  year={2015},
  publisher={Springer}
}

@article{lally2011natural,
  title={Natural language processing with prolog in the ibm watson system},
  author={Lally, Adam and Fodor, Paul},
  journal={The Association for Logic Programming (ALP) Newsletter},
  volume={9},
  year={2011}
}

@book{Clocksin1987ProgrammingIP,
  title={Programming in Prolog},
  author={W. F. Clocksin and Chris Mellish},
  booktitle={Springer Berlin Heidelberg},
  year={1987}
}

@article{Gallier1985LogicFC,
  title={Logic for Computer Science: Foundations of Automatic Theorem Proving},
  author={Jean H. Gallier},
  year={1985}
}

@article{CIATTO2021100817,
title = {2P-Kt: A logic-based ecosystem for symbolic AI},
journal = {SoftwareX},
volume = {16},
pages = {100817},
year = {2021},
issn = {2352-7110},
doi = {https://doi.org/10.1016/j.softx.2021.100817},
url = {https://www.sciencedirect.com/science/article/pii/S2352711021001126},
author = {Giovanni Ciatto and Roberta Calegari and Andrea Omicini},
keywords = {Logic programming, Artificial intelligence, Prolog, Kotlin, Prolog},
abstract = {To date, logic-based technologies are either built on top or as extensions of the Prolog language, mostly working as monolithic solutions tailored upon specific inference procedures, unification mechanisms, or knowledge representation techniques. Instead, to maximise their impact, logic-based technologies should support and enable the general-purpose exploitation of all the manifold contributions from logic programming. Accordingly, we present 2P-Kt, a reboot of the tuProlog project offering a general, extensible, and interoperable ecosystem for logic programming and symbolic AI.}
}

@book{10.5555/2843512,
author = {Rossi, Francesca and van Beek, Peter and Walsh, Toby},
title = {Handbook of Constraint Programming},
year = {2006},
isbn = {9780080463803},
publisher = {Elsevier Science Inc.},
address = {USA},
abstract = {Constraint programming is a powerful paradigm for solving combinatorial search problems that draws on a wide range of techniques from artificial intelligence, computer science, databases, programming languages, and operations research. Constraint programming is currently applied with success to many domains, such as scheduling, planning, vehicle routing, configuration, networks, and bioinformatics. The aim of this handbook is to capture the full breadth and depth of the constraint programming field and to be encyclopedic in its scope and coverage. While there are several excellent books on constraint programming, such books necessarily focus on the main notions and techniques and cannot cover also extensions, applications, and languages. The handbook gives a reasonably complete coverage of all these lines of work, based on constraint programming, so that a reader can have a rather precise idea of the whole field and its potential. Of course each line of work is dealt with in a survey-like style, where some details may be neglected in favor of coverage. However, the extensive bibliography of each chapter will help the interested readers to find suitable sources for the missing details. Each chapter of the handbook is intended to be a self-contained survey of a topic, and is written by one or more authors who are leading researchers in the area. The intended audience of the handbook is researchers, graduate students, higher-year undergraduates and practitioners who wish to learn about the state-of-the-art in constraint programming. No prior knowledge about the field is necessary to be able to read the chapters and gather useful knowledge. Researchers from other fields should find in this handbook an effective way to learn about constraint programming and to possibly use some of the constraint programming concepts and techniques in their work, thus providing a means for a fruitful cross-fertilization among different research areas. The handbook is organized in two parts. The first part covers the basic foundations of constraint programming, including the history, the notion of constraint propagation, basic search methods, global constraints, tractability and computational complexity, and important issues in modeling a problem as a constraint problem. The second part covers constraint languages and solver, several useful extensions to the basic framework (such as interval constraints, structured domains, and distributed CSPs), and successful application areas for constraint programming. - Covers the whole field of constraint programming - Survey-style chapters - Five chapters on applications Table of Contents Foreword (Ugo Montanari) Part I : Foundations Chapter 1. Introduction (Francesca Rossi, Peter van Beek, Toby Walsh) Chapter 2. Constraint Satisfaction: An Emerging Paradigm (Eugene C. Freuder, Alan K. Mackworth) Chapter 3. Constraint Propagation (Christian Bessiere) Chapter 4. Backtracking Search Algorithms (Peter van Beek) Chapter 5. Local Search Methods (Holger H. Hoos, Edward Tsang) Chapter 6. Global Constraints (Willem-Jan van Hoeve, Irit Katriel) Chapter 7. Tractable Structures for CSPs (Rina Dechter) Chapter 8. The Complexity of Constraint Languages (David Cohen, Peter Jeavons) Chapter 9. Soft Constraints (Pedro Meseguer, Francesca Rossi, Thomas Schiex) Chapter 10. Symmetry in Constraint Programming (Ian P. Gent, Karen E. Petrie, Jean-Francois Puget) Chapter 11. Modelling (Barbara M. Smith) Part II : Extensions, Languages, and Applications Chapter 12. Constraint Logic Programming (Kim Marriott, Peter J. Stuckey, Mark Wallace) Chapter 13. Constraints in Procedural and Concurrent Languages (Thom Fruehwirth, Laurent Michel, Christian Schulte) Chapter 14. Finite Domain Constraint Programming Systems (Christian Schulte, Mats Carlsson) Chapter 15. Operations Research Methods in Constraint Programming (John Hooker) Chapter 16. Continuous and Interval Constraints(Frederic Benhamou, Laurent Granvilliers) Chapter 17. Constraints over Structured Domains (Carmen Gervet) Chapter 18. Randomness and Structure (Carla Gomes, Toby Walsh) Chapter 19. Temporal CSPs (Manolis Koubarakis) Chapter 20. Distributed Constraint Programming (Boi Faltings) Chapter 21. Uncertainty and Change (Kenneth N. Brown, Ian Miguel) Chapter 22. Constraint-Based Scheduling and Planning (Philippe Baptiste, Philippe Laborie, Claude Le Pape, Wim Nuijten) Chapter 23. Vehicle Routing (Philip Kilby, Paul Shaw) Chapter 24. Configuration (Ulrich Junker) Chapter 25. Constraint Applications in Networks (Helmut Simonis) Chapter 26. Bioinformatics and Constraints (Rolf Backofen, David Gilbert)}
}

@article{JAFFAR1994503,
title = {Constraint logic programming: a survey},
journal = {The Journal of Logic Programming},
volume = {19-20},
pages = {503-581},
year = {1994},
note = {Special Issue: Ten Years of Logic Programming},
issn = {0743-1066},
doi = {https://doi.org/10.1016/0743-1066(94)90033-7},
url = {https://www.sciencedirect.com/science/article/pii/0743106694900337},
author = {Joxan Jaffar and Michael J. Maher},
abstract = {Constraint Logic Programming (CLP) is a merger of two declarative paradigms: constraint solving and logic programming. Although a relatively new field, CLP has progressed in several quite different directions. In particular, the early fundamental concepts have been adapted to better serve in different areas of applications. In this survey of CLP, a primary goal is to give a systematic description of the major trends in terms of common fundamental concepts. The three main parts cover the theory, implementation issues, and programming for applications.}
}

@article{SWI-Prolog,
  author = {Jan Wielemaker},
  title = {SWI Prolog},
  year = {1987},
  url = {https://www.swi-prolog.org/}
}

@book{Triska12,
  author    = {Markus Triska},
  title     = {The Finite Domain Constraint Solver of {SWI-Prolog}},
  booktitle = {FLOPS},
  series    = {LNCS},
  volume    = {7294},
  year      = {2012},
  pages     = {307-316}
}

@book{Triska2016,
  author    = "Markus Triska",
  title     = "The {Boolean} Constraint Solver of {SWI-Prolog}:
               System Description",
  booktitle = "FLOPS",
  series    = "LNCS",
  volume    = 9613,
  year      = 2016,
  pages     = "45--61"
}

@article{Triska2018,
  title = "Boolean constraints in {SWI-Prolog}:
           A comprehensive system description",
  journal = "Science of Computer Programming",
  volume = "164",
  pages = "98 - 115",
  year = "2018",
  note = "Special issue of selected papers from FLOPS 2016",
  issn = "0167-6423",
  doi = "https://doi.org/10.1016/j.scico.2018.02.001",
  url = "http://www.sciencedirect.com/science/article/pii/S0167642318300273",
  author = "Markus Triska",
  keywords = "CLP(B), Boolean unification, Decision diagrams, BDD"
}

@article{10.1007/978-3-030-75775-5_27,
author = {Ciatto, Giovanni and Calegari, Roberta and Omicini, Andrea},
title = {Lazy Stream Manipulation in Prolog via Backtracking: The Case of 2P-Kt},
year = {2021},
isbn = {978-3-030-75774-8},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
url = {https://doi.org/10.1007/978-3-030-75775-5_27},
doi = {10.1007/978-3-030-75775-5_27},
abstract = {The ability to lazily manipulate long or infinite streams of data is an essential feature in the era of data-driven artificial intelligence. Yet, logic programming technologies currently fall short when it comes to handling long or infinite streams of data. In this paper, we discuss how Prolog can be reinterpreted as a stream processing tool, and re-designed around an abstract state-machine capable of lazily manipulating streams of data via backtracking.},
booktitle = {Logics in Artificial Intelligence: 17th European Conference, JELIA 2021, Virtual Event, May 17–20, 2021, Proceedings},
pages = {407–420},
numpages = {14},
keywords = {Prolog, State machine, Stream processing, 2P-Kt}
}

@book{gamma1994design,
  added-at = {2010-06-05T16:40:25.000+0200},
  asin = {0201633612},
  author = {Gamma, Erich and Helm, Richard and Johnson, Ralph and Vlissides, John M.},
  biburl = {https://www.bibsonomy.org/bibtex/27e3f1154ab1fbce54752a46dba7f2217/pnk},
  description = {Amazon.com: Design Patterns: Elements of Reusable Object-Oriented Software (9780201633610): Erich Gamma, Richard Helm, Ralph Johnson, John M. Vlissides: Books},
  dewey = {005.12},
  ean = {9780201633610},
  edition = 1,
  interhash = {7fe32957be97afaf4ecb38b5490d23b4},
  intrahash = {7e3f1154ab1fbce54752a46dba7f2217},
  isbn = {0201633612},
  keywords = {DBIS Design Object-Oriented Patterns SS2010 Seminar Software},
  publisher = {Addison-Wesley Professional},
  timestamp = {2010-06-05T16:40:25.000+0200},
  title = {Design Patterns: Elements of Reusable Object-Oriented Software},
  url = {http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=ntt_at_ep_dpi_1},
  year = 1994
}

@article{Prudhomme2022, 
  doi = {10.21105/joss.04708}, 
  url = {https://doi.org/10.21105/joss.04708}, 
  year = {2022}, 
  publisher = {The Open Journal}, 
  volume = {7}, 
  number = {78}, 
  pages = {4708}, 
  author = {Charles Prud'homme and Jean-Guillaume Fages}, 
  title = {Choco-solver: A Java library for constraint programming},
  journal = {Journal of Open Source Software} 
}

@article{ortools,
  title = {OR-Tools},
  version = { v9.5 },
  author = {Laurent Perron and Vincent Furnon},
  organization = {Google},
  url = {https://developers.google.com/optimization/},
  date = { 2022-11-25 }
}

@book{Kuchcinski2013JaCoPJ,
  title={JaCoP - Java Constraint Programming Solver},
  author={Krzysztof Kuchcinski and Radoslaw Szymanek},
  booktitle={International Conference on Principles and Practice of Constraint Programming},
  year={2013}
}

@article{inbook,
author = {Parasumanna Gokulan, Balaji and Srinivasan, D.},
year = {2010},
month = {07},
pages = {1-27},
title = {An Introduction to Multi-Agent Systems},
volume = {310},
isbn = {978-3-642-14434-9},
journal = {Studies in Computational Intelligence},
doi = {10.1007/978-3-642-14435-6_1}
}

@article{10.5555/1695886,
author = {Wooldridge, Michael},
title = {An Introduction to MultiAgent Systems},
year = {2009},
isbn = {0470519460},
publisher = {Wiley Publishing},
edition = {2nd},
abstract = {The study of multi-agent systems (MAS) focuses on systems in which many intelligent agents interact with each other. These agents are considered to be autonomous entities such as software programs or robots. Their interactions can either be cooperative (for example as in an ant colony) or selfish (as in a free market economy). This book assumes only basic knowledge of algorithms and discrete maths, both of which are taught as standard in the first or second year of computer science degree programmes. A basic knowledge of artificial intelligence would useful to help understand some of the issues, but is not essential. The books main aims are: To introduce the student to the concept of agents and multi-agent systems, and the main applications for which they are appropriate To introduce the main issues surrounding the design of intelligent agents To introduce the main issues surrounding the design of a multi-agent society To introduce a number of typical applications for agent technology}
}

@article{10.1007/3-540-44631-1_7,
author="Bellifemine, Fabio
and Poggi, Agostino
and Rimassa, Giovanni",
editor="Castelfranchi, Cristiano
and Lesp{\'e}rance, Yves",
title="Developing Multi-agent Systems with JADE",
booktitle="Intelligent Agents VII Agent Theories Architectures and Languages",
year="2001",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="89--103",
abstract="JADE (Java Agent Development Framework) is a software framework to make easy the development of multi-agent applications in compliance with the FIPA specifications. JADE can then be considered a middle-ware that implements an efficient agent platform and supports the development of multi agent systems. JADE agent platform tries to keep high the performance of a distributed agent system implemented with the Java language. In particular, its communication architecture tries to offer flexible and efficient messaging, transparently choosing the best transport available and leveraging state-of-the-art distributed object technology embedded within Java runtime environment. JADE uses an agent model and Java implementation that allow good runtime efficiency, software reuse, agent mobility and the realization of different agent architectures.",
isbn="978-3-540-44631-6"
}

@article{10.3233/FI-2018-1695,
author = {Calegari, Roberta and Denti, Enrico and Dovier, Agostino and Omicini, Andrea and Fiorentini, Camillo and Momigliano, Alberto and Pettorossi, Alberto},
title = {Extending Logic Programming with Labelled Variables: Model and Semantics},
year = {2018},
issue_date = {2018},
publisher = {IOS Press},
address = {NLD},
volume = {161},
number = {1–2},
issn = {0169-2968},
url = {https://doi.org/10.3233/FI-2018-1695},
doi = {10.3233/FI-2018-1695},
abstract = {In order to enable logic programming to deal with the diversity of pervasive systems, where many heterogeneous, domain-specific computational models could benefit from the power of symbolic computation, we explore the expressive power of labelled systems. To this end, we define a new notion of truth for logic programs extended with labelled variables interpreted in non-Herbrand domains—where, however, terms maintain their usual Herbrand interpretations.First, a model for labelled variables in logic programming is defined. Then, the fixpoint and the operational semantics are presented and their equivalence is formally proved. A meta-interpreter implementing the operational semantics is also introduced, followed by some case studies aimed at showing the effectiveness of our approach in selected scenarios.},
journal = {Fundam. Inf.},
month = {jan},
pages = {53–74},
numpages = {22},
keywords = {meta-interpretation, situated intelligence, labelled variables, formal semantics, logic programming, logic programming}
}

@article{10.1093/logcom/2.6.719,
    author = {KAKAS, A. C. and KOWALSKI, R. A. and TONI, F.},
    title = "{Abductive Logic Programming}",
    journal = {Journal of Logic and Computation},
    volume = {2},
    number = {6},
    pages = {719-770},
    year = {1992},
    month = {12},
    abstract = "{This paper is a survey and critical overview of recent work on the extension of logic programming to perform abductive reasoning (abductive logic programming). We outline the general framework of abduction and its applications to knowledge assimilation and default reasoning; and we introduce an argumentation-theoretic approach to the use of abduction as an interpretation for negation as failure. We also analyse the links between abduction and the extension of logic programming obtained by adding a form of explicit negation. Finally we discuss the relation between abduction and truth maintenance.}",
    issn = {0955-792X},
    doi = {10.1093/logcom/2.6.719},
    url = {https://doi.org/10.1093/logcom/2.6.719},
    eprint = {https://academic.oup.com/logcom/article-pdf/2/6/719/2776092/2-6-719.pdf},
}

@book{10.5555/94469,
editor = {Abramson, Harvey and Rogers, M. H.},
title = {Meta-Programming in Logic Programming},
year = {1989},
isbn = {0262510472},
publisher = {MIT Press},
address = {Cambridge, MA, USA}
}

@inproceedings{10.1145/800223.806776,
author = {Clark, Keith L. and Gregory, Steve},
title = {A Relational Language for Parallel Programming},
year = {1981},
isbn = {0897910605},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/800223.806776},
doi = {10.1145/800223.806776},
abstract = {A parallel program often defines a relation not a function. The program constrains the output to lie in some relation R to the input, but the particular output produced during a computation can depend on the time behaviour of component processes. This suggests the use of a relational language as an applicative language for parallel programming.The Horn clause subset of predicate logic is a relational language with an established procedural interpretation for non-deterministic sequential computations [Kowalski 1974]. In this paper we modify and extend that interpretation to define a special purpose parallel evaluator.},
booktitle = {Proceedings of the 1981 Conference on Functional Programming Languages and Computer Architecture},
pages = {171–178},
numpages = {8},
location = {Portsmouth, New Hampshire, USA},
series = {FPCA '81}
}

@article{NG1992150,
title = {Probabilistic logic programming},
journal = {Information and Computation},
volume = {101},
number = {2},
pages = {150-201},
year = {1992},
issn = {0890-5401},
doi = {https://doi.org/10.1016/0890-5401(92)90061-J},
url = {https://www.sciencedirect.com/science/article/pii/089054019290061J},
author = {Raymond Ng and V.S. Subrahmanian},
abstract = {Of all scientific investigations into reasoning with uncertainty and chance, probability theory is perhaps the best understood paradigm. Nevertheless, all studies conducted thus far into the semantics of quantitative logic programming have restricted themselves to non-probabilistic semantic characterizations. In this paper, we take a few steps towards rectifying this situation. We define a logic programming language that is syntactically similar to the annotated logics of Blair et al., 1987, Blair and Subrahmanian, 1988, 45–73) but in which the truth values are interpreted probabilistically. A probabilistic model theory and fixpoint theory is developed for such programs. This probabilistic model theory satisfies the requirements proposed by Fenstad (in “Studies in Inductive Logic and Probabilities” (R. C. Jeffrey, Ed.), Vol. 2, pp. 251–262, Univ. of California Press, Berkeley, 1980) for a function to be called probabilistic. The logical treatment of probabilities is complicated by two facts: first, that the connectives cannot be interpreted truth-functionally when truth values are regarded as probabilities; second, that negation-free definite-clause-like sentences can be inconsistent when interpreted probabilistically. We address these issues here and propose a formalism for probabilistic reasoning in logic programming. To our knowledge, this is the first probabilistic characterization of logic programming semantics.}
}

@InProceedings{10.1007/978-3-540-74970-7_38,
author="Nethercote, Nicholas
and Stuckey, Peter J.
and Becket, Ralph
and Brand, Sebastian
and Duck, Gregory J.
and Tack, Guido",
editor="Bessi{\`e}re, Christian",
title="MiniZinc: Towards a Standard CP Modelling Language",
booktitle="Principles and Practice of Constraint Programming -- CP 2007",
year="2007",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="529--543",
abstract="There is no standard modelling language for constraint programming (CP) problems. Most solvers have their own modelling language. This makes it difficult for modellers to experiment with different solvers for a problem.",
isbn="978-3-540-74970-7"
}



